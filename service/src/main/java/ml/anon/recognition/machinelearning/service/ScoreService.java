package ml.anon.recognition.machinelearning.service;


import ml.anon.anonymization.model.Anonymization;
import ml.anon.anonymization.model.Label;
import ml.anon.anonymization.model.Producer;
import ml.anon.anonymization.model.Status;
import ml.anon.documentmanagement.model.Document;
import ml.anon.documentmanagement.resource.DocumentResource;
import ml.anon.recognition.machinelearning.model.DocEvaluation;
import ml.anon.recognition.machinelearning.model.EvaluationData;
import ml.anon.recognition.machinelearning.repository.DocEvaluationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.*;

/**
 *
 */
@Service
public class ScoreService implements IScoreService {

    @Resource
    private DocumentResource documentResource;

    @Autowired
    private DocEvaluationRepository docEvaluationRepository;

    @Override
    public boolean prepareNumbers(String documentId) {

        Document document = documentResource.findById(documentId);

        List<Anonymization> filteredGenerated = this.getGenerated(document.getAnonymizations());
        List<Anonymization> filteredCorrected = this.filterByProducer(document.getAnonymizations());

        double numberOfGenerated = filteredGenerated.size();
        double numberOfCorrected = filteredCorrected.size();
        double numberOfCorrectFound = this.countCorrectFound(filteredGenerated, filteredCorrected);

        this.calculateScores(numberOfGenerated, numberOfCorrected, numberOfCorrectFound, documentId);

        return true;
    }

    /**
     * Calculates the evaluation scores and saves them (if an document id is given) or just retuns the Evaluation data.
     * @param generated the Anonymizations generated by the NER
     * @param corrected the Anonymizations corrected by human interaction
     * @param correctFound the Anonymizations which are identical in both generated and corrected (different Labels are
     *                     ignored
     * @param documentId the corresponding document
     * @return the calculated Evaluation data
     */
    private EvaluationData calculateScores(double generated, double corrected, double correctFound, String documentId) {

        double precision = correctFound / generated;
        double recall = correctFound / corrected;
        double fOneScore = this.calculatetFOne(precision, recall);

        System.out.println("Precision: " + precision);
        System.out.println("Recall: " + recall);
        System.out.println("F1: " + fOneScore);

        if(documentId != null){
            DocEvaluation docEvaluation = docEvaluationRepository.findByDocumentId(documentId);
            if(docEvaluation == null){
                docEvaluation = DocEvaluation.builder().documentId(documentId).build();
            }

            docEvaluation.setTotalCorrected(corrected);
            docEvaluation.setTotalGenerated(generated);
            docEvaluation.setTotalNumberOfCorrectFound(correctFound);

            docEvaluation.setOverallPrecision(precision);
            docEvaluation.setOverallRecall(recall);
            docEvaluation.setOverallFOne(fOneScore);

            docEvaluationRepository.save(docEvaluation);
            return docEvaluation;

        } else {
            EvaluationData evaluationData = new EvaluationData();

            evaluationData.setTotalCorrected(corrected);
            evaluationData.setTotalGenerated(generated);
            evaluationData.setTotalNumberOfCorrectFound(correctFound);

            evaluationData.setOverallPrecision(precision);
            evaluationData.setOverallRecall(recall);
            evaluationData.setOverallFOne(fOneScore);

            return evaluationData;
        }
    }

    private double calculatetFOne(double precision, double recall) {
        return (2 * precision * recall) / (precision + recall);
    }

    @Override
    public EvaluationData getOverallEvaluationData() {
        double totalGenerated = 0;
        double totalCorrected = 0;
        double totalCorrectFound = 0;

        for (DocEvaluation docEvaluation: docEvaluationRepository.findAll()) {
            totalGenerated += docEvaluation.getTotalGenerated();
            totalCorrected += docEvaluation.getTotalCorrected();
            totalCorrectFound += docEvaluation.getTotalNumberOfCorrectFound();
        }
        return this.calculateScores(totalGenerated, totalCorrected, totalCorrectFound, null);
    }

    /**
     * Counts the correct found {@link Anonymization} objects. Basically all {@link Anonymization} added by human were
     * not correctly found, but all {@link Anonymization} which are still contained in the corrected data are correct
     * (it is ignored if the {@link Label} was changed)
     *
     * @param filteredGenerated the from the ml module produced {@link Anonymization}s
     * @param filteredCorrected the {@link Anonymization}s produced by the ml module and from the human interacting
     * @return the number of found correct {@link Anonymization}s
     */
    private double countCorrectFound(List<Anonymization> filteredGenerated, List<Anonymization> filteredCorrected) {
        double numberOfCorrectFound = 0;
        for (Anonymization generated : filteredGenerated) {

            for (Anonymization corrected : filteredCorrected) {
                if (generated.getData().getOriginal().equals(corrected.getData().getOriginal())
                        && corrected.getProducer().equals(Producer.ML)) {
                    numberOfCorrectFound++;
                    break;
                }
            }
        }

        return numberOfCorrectFound;
    }

    /**
     * Filters the list by {@link Producer} and {@link Label} so that only labels are regarded if they are produced by
     * the ml module to keep the evaluation scores representative
     *
     * @param anonymizations list of {@link Anonymization} objects which should be filtered
     * @return the filtered list
     */
    private List<Anonymization> filterByProducer(List<Anonymization> anonymizations) {
        List<Anonymization> filtered = new ArrayList<Anonymization>();
        for (Anonymization anonymization : anonymizations) {

            if (!anonymization.getStatus().equals(Status.DECLINED)
                    && (anonymization.getProducer().equals(Producer.ML)
                    || anonymization.getProducer().equals(Producer.HUMAN))
                    && (anonymization.getData().getLabel().equals(Label.MISC)
                    || anonymization.getData().getLabel().equals(Label.LOCATION)
                    || anonymization.getData().getLabel().equals(Label.ORGANIZATION)
                    || anonymization.getData().getLabel().equals(Label.PERSON))) {
                filtered.add(anonymization);
            }
        }
        return filtered;
    }

    /**
     * Filteres out only the Anonymization objects that were generated by the ml service
     * @param anonymizations to be filtered
     * @return generated Anonymizations
     */
    private List<Anonymization> getGenerated(List<Anonymization> anonymizations) {
        List<Anonymization> filtered = new ArrayList<Anonymization>();

        for (Anonymization anonymization : anonymizations) {

            if (anonymization.getProducer().equals(Producer.ML)) {
                filtered.add(anonymization);
            }
        }
        return filtered;


    }
}
