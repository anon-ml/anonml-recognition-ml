package ml.anon.recognition.machinelearning.service;


import com.google.common.collect.Iterables;
import ml.anon.anonymization.model.Anonymization;
import ml.anon.anonymization.model.Label;
import ml.anon.anonymization.model.Producer;
import ml.anon.anonymization.model.Status;
import ml.anon.documentmanagement.model.Document;
import ml.anon.documentmanagement.resource.DocumentResource;
import ml.anon.recognition.machinelearning.model.Configuration;
import ml.anon.recognition.machinelearning.model.DocEvaluation;
import ml.anon.recognition.machinelearning.model.EvaluationData;
import ml.anon.recognition.machinelearning.repository.ConfigurationRepository;
import ml.anon.recognition.machinelearning.repository.DocEvaluationRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;
import java.util.*;
import java.util.stream.Collectors;

/**
 *
 */
@Service
public class ScoreService implements IScoreService {

    @Resource
    private ConfigurationRepository configRepo;

    @Resource
    private DocumentResource documentResource;

    @Autowired
    private DocEvaluationRepository docEvaluationRepository;

    @Override
    public boolean prepareNumbers(String documentId) {

        Document document = documentResource.findById(documentId);

        List<Anonymization> filteredGenerated = this.getGenerated(document.getAnonymizations());
        List<Anonymization> filteredCorrected = this.filterByProducer(document.getAnonymizations());

        double numberOfGenerated = filteredGenerated.size();
        double numberOfCorrected = filteredCorrected.size();
        double numberOfCorrectFound = this.countCorrectFound(filteredGenerated, filteredCorrected);

        this.calculateScores(numberOfGenerated, numberOfCorrected, numberOfCorrectFound, documentId);

        return true;
    }

    /**
     * Calculates the evaluation scores and saves them (if an document id is given) or just retuns the Evaluation data.
     *
     * @param generated    the Anonymizations generated by the NER
     * @param corrected    the Anonymizations corrected by human interaction
     * @param correctFound the Anonymizations which are identical in both generated and corrected (different Labels are
     *                     ignored
     * @param documentId   the corresponding document
     * @return the calculated Evaluation data
     */
    private EvaluationData calculateScores(double generated, double corrected, double correctFound, String documentId) {

        double precision = correctFound / generated;
        double recall = correctFound / corrected;
        double fOneScore = this.calculatetFOne(precision, recall);

        if (documentId != null) {
            DocEvaluation docEvaluation = docEvaluationRepository.findByDocumentId(documentId);
            if (docEvaluation == null) {
                docEvaluation = DocEvaluation.builder().documentId(documentId).build();
            }

            docEvaluation.setCorrected(corrected);
            docEvaluation.setGenerated(generated);
            docEvaluation.setCorrectFound(correctFound);

            docEvaluation.setPrecision(precision);
            docEvaluation.setRecall(recall);
            docEvaluation.setFOne(fOneScore);

            docEvaluationRepository.save(docEvaluation);
            return docEvaluation;

        } else {
            List<Configuration> dates = configRepo.findAll();
            dates.sort(Comparator.comparing(Configuration::getResetDate).reversed());
            EvaluationData evaluationData = new EvaluationData();
            evaluationData.setLastReset(Iterables.getFirst(dates, new Configuration()).getResetDate());
            evaluationData.setCorrected(corrected);
            evaluationData.setGenerated(generated);
            evaluationData.setCorrectFound(correctFound);

            evaluationData.setPrecision(precision);
            evaluationData.setRecall(recall);
            evaluationData.setFOne(fOneScore);

            return evaluationData;
        }
    }

    private double calculatetFOne(double precision, double recall) {
        return (2 * precision * recall) / (precision + recall);
    }

    @Override
    public EvaluationData getOverallEvaluationData() {
        double totalGenerated = 0;
        double totalCorrected = 0;
        double totalCorrectFound = 0;

        List<Configuration> dates = configRepo.findAll();
        dates.sort(Comparator.comparing(Configuration::getResetDate).reversed());


        // TODO: delete DocEvaluation if Document is deleted?
        List<DocEvaluation> all = docEvaluationRepository.findAll().stream().filter(eval -> eval.getCreated().after(Iterables.getFirst(dates, new Configuration(new Date(0L))).getResetDate())).collect(Collectors.toList());
        for (DocEvaluation docEvaluation : all) {
            totalGenerated += docEvaluation.getGenerated();
            totalCorrected += docEvaluation.getCorrected();
            totalCorrectFound += docEvaluation.getCorrectFound();
        }
        return this.calculateScores(totalGenerated, totalCorrected, totalCorrectFound, null);
    }

    /**
     * Counts the correct found {@link Anonymization} objects. Basically all {@link Anonymization} added by human were
     * not correctly found, but all {@link Anonymization} which are still contained in the corrected data are correct
     * (it is ignored if the {@link Label} was changed)
     *
     * @param filteredGenerated the from the ml module produced {@link Anonymization}s
     * @param filteredCorrected the {@link Anonymization}s produced by the ml module and from the human interacting
     * @return the number of found correct {@link Anonymization}s
     */
    private double countCorrectFound(List<Anonymization> filteredGenerated, List<Anonymization> filteredCorrected) {
        double numberOfCorrectFound = 0;
        for (Anonymization generated : filteredGenerated) {

            for (Anonymization corrected : filteredCorrected) {
                if (generated.getData().getOriginal().equals(corrected.getData().getOriginal())
                        && corrected.getProducer().equals(Producer.ML)) {
                    numberOfCorrectFound++;
                    break;
                }
            }
        }

        return numberOfCorrectFound;
    }

    /**
     * Filters the list by {@link Producer} and {@link Label} so that only labels are regarded if they are produced by
     * the ml module to keep the evaluation scores representative
     *
     * @param anonymizations list of {@link Anonymization} objects which should be filtered
     * @return the filtered list
     */
    private List<Anonymization> filterByProducer(List<Anonymization> anonymizations) {
        List<Anonymization> filtered = new ArrayList<Anonymization>();
        for (Anonymization anonymization : anonymizations) {

            if (!anonymization.getStatus().equals(Status.DECLINED)
                    && (anonymization.getProducer().equals(Producer.ML)
                    || anonymization.getProducer().equals(Producer.HUMAN))
                    && (anonymization.getData().getLabel().equals(Label.MISC)
                    || anonymization.getData().getLabel().equals(Label.LOCATION)
                    || anonymization.getData().getLabel().equals(Label.ORGANIZATION)
                    || anonymization.getData().getLabel().equals(Label.PERSON))) {
                filtered.add(anonymization);
            }
        }
        return filtered;
    }

    /**
     * Filteres out only the Anonymization objects that were generated by the ml service
     *
     * @param anonymizations to be filtered
     * @return generated Anonymizations
     */
    private List<Anonymization> getGenerated(List<Anonymization> anonymizations) {
        List<Anonymization> filtered = new ArrayList<Anonymization>();

        for (Anonymization anonymization : anonymizations) {

            if (anonymization.getProducer().equals(Producer.ML)) {
                filtered.add(anonymization);
            }
        }
        return filtered;


    }
}
